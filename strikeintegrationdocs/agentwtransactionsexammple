// src/interfaces.ts

/**
 * Common Types as defined in the Strike Finance API documentation.
 */
export interface Asset {
  policyId: string;
  assetName: string;
}

export interface OutRef {
  txHash: string;
  outputIndex: number;
}

export type Side = "Long" | "Short";

export interface AssetInfo {
  asset: Asset;
  ticker: string;
  type: string;
  url: string;
  decimals: number;
  dex: string;
  perpAuthPolicyId: string;
}

export interface PoolInfo {
  totalAssetAmount: number;
  availableAssetAmount: number;
  totalLpMinted: number;
  totalValueLocked: number;
}

export interface MarketInfo {
  longInterest: number;
  shortInterest: number;
}

/**
 * Position Management Interfaces
 */
export interface OpenPositionRequest {
  request: {
    bech32Address: string;
    leverage: number;
    position: Side;
    asset: Asset;
    collateralAmount: number;
    positionSize: number;
    enteredPrice: number;
    positionType: string;
  };
}

export interface ClosePositionRequest {
  request: {
    address: string;
    asset: Asset;
    outRef: OutRef;
    positionSize: number;
    positionType: string;
    collateralAmount: number;
    position: Side;
  };
}

export interface UpdatePositionRequest {
  request: {
    address: string;
    asset: Asset;
    outRef: OutRef;
    stopLossPrice: number;
    takeProfitPrice: number;
  };
}

export interface PerpetualInfo {
  position: Side;
  positionSize: number;
  leverage: number;
  stopLoss: number;
  takeProfit: number;
  asset: {
    ticker: string;
    asset: Asset;
  };
  assetName: string;
  type: string;
  url: string;
  decimals: number;
  dex: string;
  perpAuthPolicyId: string;
  collateral: {
    amount: number;
    ticker: string;
  };
  entryPrice: number;
  isPending: boolean;
  outRef: OutRef;
  enteredPositionTime: number;
  status: "Pending" | "Completed";
  liquidationPrice: number;
  hourlyBorrowFee: number;
}

/**
 * Transaction History Interfaces
 */
export interface PerpetualTransactionInfo {
    contract: "Perpetual";
    action: string;
    assetTicker: string;
    type: "Perpetual";
    pair: string;
    time: number;
    address: string;
    txHash: string;
    status: string;
    enteredPrice: number;
    positionSize: number;
    positionType: string;
    collateralAmount: number;
    description: string;
    pnl: number;
    usdPrice?: number;
    leverage?: number;
    currentPrice: number;
}

// src/strike-finance-api.ts
import axios, { AxiosInstance } from "axios";
import {
  OpenPositionRequest,
  ClosePositionRequest,
  UpdatePositionRequest,
  PerpetualInfo,
  PoolInfo,
  MarketInfo,
  PerpetualTransactionInfo,
} from "./interfaces";

export class StrikeFinanceAPI {
  private readonly client: AxiosInstance;
  private readonly baseUrl = "https://app.strikefinance.org";

  constructor() {
    this.client = axios.create({
      baseURL: this.baseUrl,
      headers: {
        "Content-Type": "application/json",
      },
    });
  }

  /**
   * Opens a new perpetual position.
   * @param data - The request body for opening a position.
   * @returns A promise that resolves with the CBOR string for the transaction.
   */
  async openPosition(data: OpenPositionRequest): Promise<{ cbor: string }> {
    const response = await this.client.post("/api/perpetuals/openPosition", data);
    return response.data;
  }

  /**
   * Closes an existing perpetual position.
   * @param data - The request body for closing a position.
   * @returns A promise that resolves with the CBOR string for the transaction.
   */
  async closePosition(data: ClosePositionRequest): Promise<{ cbor: string }> {
    const response = await this.client.post("/api/perpetuals/closePosition", data);
    return response.data;
  }

  /**
   * Updates an existing perpetual position.
   * @param data - The request body for updating a position.
   * @returns A promise that resolves with the CBOR string for the transaction.
   */
  async updatePosition(data: UpdatePositionRequest): Promise<{ cbor: string }> {
      const response = await this.client.post("/api/perpetuals/updatePosition", data);
      return response.data;
  }

  /**
   * Retrieves all active and pending positions for a given address.
   * @param address - The wallet address to query positions for.
   * @returns A promise that resolves with an array of perpetual information.
   */
  async getPositions(address: string): Promise<PerpetualInfo[]> {
    const response = await this.client.get(`/api/perpetuals/getPositions?address=${address}`);
    return response.data;
  }

  /**
   * Retrieves information about the V2 perpetuals liquidity pool.
   * @returns A promise that resolves with the pool information.
   */
  async getPoolInfoV2(): Promise<{ data: PoolInfo }> {
      const response = await this.client.get("/api/perpetuals/getPoolInfoV2");
      return response.data;
  }

  /**
   * Retrieves overall market information.
   * @returns A promise that resolves with the market information.
   */
  async getOverallInfo(): Promise<{ data: MarketInfo }> {
      const response = await this.client.get("/api/perpetuals/getOverallInfo");
      return response.data;
  }

  /**
   * Retrieves the perpetual transaction history for a specific address.
   * @param address - The wallet address to query history for.
   * @returns A promise that resolves with the transaction history.
   */
  async getPerpetualHistory(address: string): Promise<{ transactions: PerpetualTransactionInfo[] }> {
      const response = await this.client.get(`/api/perpetuals/getPerpetualHistory?address=${address}`);
      return response.data;
  }
}

// src/cardano-wallet.ts
import * as CSL from "@emurgo/cardano-serialization-lib-nodejs";
import {MastraAgent} from "./mastra-agent";

export class CardanoWallet {
    private privateKey: CSL.PrivateKey;
    public readonly address: string;

    constructor(privateKeyBech32: string) {
        this.privateKey = CSL.PrivateKey.from_bech32(privateKeyBech32);
        const publicKey = this.privateKey.to_public();
        const stakeKey = CSL.StakeCredential.from_keyhash(publicKey.hash());
        const baseAddress = CSL.BaseAddress.new(
            CSL.NetworkInfo.mainnet().network_id(),
            CSL.StakeCredential.from_keyhash(publicKey.hash()),
            stakeKey
        );
        this.address = baseAddress.to_address().to_bech32();
    }

    /**
     * Signs and submits a transaction to the Cardano network.
     * @param txCbor - The transaction CBOR to sign and submit.
     * @returns The transaction hash.
     */
    async signAndSubmitTx(txCbor: string): Promise<string> {
        console.log("Signing and submitting transaction...");

        const transaction = CSL.Transaction.from_bytes(Buffer.from(txCbor, "hex"));
        const txBody = transaction.body();
        const txHash = CSL.hash_transaction(txBody);
        const witnesses = CSL.TransactionWitnessSet.new();
        const vkeyWitnesses = CSL.Vkeywitnesses.new();
        const vkeyWitness = CSL.make_vkey_witness(txHash, this.privateKey);
        vkeyWitnesses.add(vkeyWitness);
        witnesses.set_vkeys(vkeyWitnesses);

        const signedTx = CSL.Transaction.new(
            txBody,
            witnesses,
            transaction.auxiliary_data()
        );

        const submittedTxHash = await this.submitTx(signedTx.to_bytes());
        console.log("Transaction submitted with hash:", submittedTxHash);
        return submittedTxHash;
    }

    /**
     * Submits a transaction to the network.
     * This is a placeholder and should be replaced with a real implementation
     * that uses a service like Blockfrost or a local Cardano node.
     * @param signedTx - The signed transaction bytes.
     * @returns The transaction hash.
     */
    private async submitTx(signedTx: Uint8Array): Promise<string> {
        // In a real application, you would use a service like Blockfrost
        // to submit the transaction to the Cardano network.
        console.log("Submitting transaction to the network (mock)...");
        const txHash = CSL.hash_transaction(CSL.Transaction.from_bytes(signedTx).body()).to_hex();
        console.log(`Mock submission successful. Tx Hash: ${txHash}`);
        return txHash;
    }
}


// src/price-service.ts
export class PriceService {
    /**
     * Fetches the current price of ADA.
     * This is a mock implementation. In a real application, you would use a
     * reliable price oracle or an exchange API.
     * @returns The current price of ADA in USD.
     */
    async getAdaPrice(): Promise<number> {
        // Mock price feed
        return 0.45 + (Math.random() - 0.5) * 0.05;
    }
}


// src/strategies/titan2k-trend-tuned.ts
import { TradingStrategy, TradingDecision } from "../trading-strategies";
import { MarketInfo, PerpetualInfo } from "../interfaces";
import * as pd from "danfojs-node";

export class TITAN2KTrendTuned extends TradingStrategy {
    private readonly aggressiveMode: boolean;
    private readonly timeframeWeights = {
        daily: 0.6,
        medium: 0.25,
        lower: 0.15,
    };
    private readonly trendStrengthThreshold = 0.5; // Example value
    private readonly maxPositionSize = 1; // Example value
    private readonly maxLeverage = 10; // Example value
    private readonly trailingStopMultiplier = 1.5; // Example value
    private readonly profitTargetMultiplier = 3; // Example value

    constructor(aggressiveMode: boolean = true) {
        super();
        this.aggressiveMode = aggressiveMode;
    }

    evaluate(marketInfo: MarketInfo, existingPositions: PerpetualInfo[], priceData: pd.DataFrame): TradingDecision {
        console.log("Evaluating TITAN2K Trend-Tuned Strategy...");

        if (priceData.shape[0] < 200) {
            console.log("Not enough data to evaluate strategy.");
            return { action: "Hold" };
        }

        const dfWithIndicators = this.calculateIndicators(priceData);
        const dfWithSignals = this.generateSignals(dfWithIndicators);

        const latestSignal = dfWithSignals.iloc(dfWithSignals.shape[0] - 1);

        if (latestSignal["signal"] === "BUY") {
            const hasLongPosition = existingPositions.some(p => p.position === "Long");
            if (!hasLongPosition) {
                return {
                    action: "Open",
                    params: {
                        position: "Long",
                        leverage: latestSignal["leverage"],
                        collateralAmount: 1000000000, // 1000 ADA
                        positionSize: latestSignal["position_size"] * 5000000000, // Example
                        stop_loss: latestSignal["stop_loss"],
                        take_profit: latestSignal["take_profit"],
                    },
                };
            }
        } else if (latestSignal["signal"] === "SELL") {
            const hasShortPosition = existingPositions.some(p => p.position === "Short");
            if (!hasShortPosition) {
                return {
                    action: "Open",
                    params: {
                        position: "Short",
                        leverage: latestSignal["leverage"],
                        collateralAmount: 1000000000, // 1000 ADA
                        positionSize: latestSignal["position_size"] * 5000000000, // Example
                        stop_loss: latestSignal["stop_loss"],
                        take_profit: latestSignal["take_profit"],
                    },
                };
            }
        }

        return { action: "Hold" };
    }

    private calculateIndicators(df: pd.DataFrame): pd.DataFrame {
        let new_df = df.copy();
        new_df["ema50"] = new_df["close"].ewm({ com: 50 }).mean();
        new_df["ema200"] = new_df["close"].ewm({ com: 200 }).mean();
        new_df["ema50_roc"] = new_df["ema50"].pct_change({ periods: 20 }).mul(100);
        new_df["ema200_roc"] = new_df["ema200"].pct_change({ periods: 20 }).mul(100);

        const bearMarket = new_df["close"].lt(new_df["ema200"])
            .and(new_df["ema50"].lt(new_df["ema200"]))
            .and(new_df["ema50_roc"].lt(-0.5));
        new_df["bear_market"] = bearMarket.astype("int");

        const bullMarket = new_df["close"].gt(new_df["ema200"])
            .and(new_df["ema50"].gt(new_df["ema200"]))
            .and(new_df["ema50_roc"].gt(0.5));
        new_df["bull_market"] = bullMarket.astype("int");

        // Add other indicators from TITAN2KModel as needed
        new_df["atr14"] = new_df["close"].rolling(14).std(); // Simplified ATR
        new_df["combined_trend"] = new_df["ema50_roc"]; // Simplified combined trend
        new_df["timeframe_alignment"] = new_df["ema200_roc"]; // Simplified alignment


        return new_df;
    }

    private generateSignals(df: pd.DataFrame): pd.DataFrame {
        let new_df = df.copy();
        new_df.addColumn("signal", Array(new_df.shape[0]).fill("NEUTRAL"), { inplace: true });
        new_df.addColumn("confidence", Array(new_df.shape[0]).fill(0.0), { inplace: true });
        new_df.addColumn("position_size", Array(new_df.shape[0]).fill(0.0), { inplace: true });
        new_df.addColumn("leverage", Array(new_df.shape[0]).fill(1.0), { inplace: true });
        new_df.addColumn("stop_loss", Array(new_df.shape[0]).fill(null), { inplace: true });
        new_df.addColumn("take_profit", Array(new_df.shape[0]).fill(null), { inplace: true });


        for (let i = 200; i < new_df.shape[0]; i++) {
            const row = new_df.iloc({ rows: [i] });

            const bearMarket = row["bear_market"].values[0] === 1;
            const bullMarket = row["bull_market"].values[0] === 1;
            const combinedTrend = row["combined_trend"].values[0];
            const timeframeAlignment = row["timeframe_alignment"].values[0];
            let signal = "NEUTRAL";
            let confidence = 0.0;

            if (combinedTrend >= this.trendStrengthThreshold) {
                signal = "BUY";
                confidence = Math.min(Math.abs(combinedTrend), 0.99);
            } else if (combinedTrend <= -this.trendStrengthThreshold) {
                signal = "SELL";
                confidence = Math.min(Math.abs(combinedTrend), 0.99);
            }

            if (bearMarket && signal === "BUY" && (confidence < 0.7 || timeframeAlignment < 0.7)) {
                signal = "NEUTRAL";
            }
            if (bullMarket && signal === "SELL" && (confidence < 0.7 || timeframeAlignment < 0.7)) {
                signal = "NEUTRAL";
            }

            if (signal !== "NEUTRAL") {
                const positionSize = timeframeAlignment * this.maxPositionSize;
                const leverage = 1.0 + (Math.abs(combinedTrend) * (this.maxLeverage - 1.0));
                const atr = row["atr14"].values[0];
                const closePrice = row["close"].values[0];
                let stopLoss, takeProfit;

                if (signal === "BUY") {
                    stopLoss = closePrice - atr * this.trailingStopMultiplier;
                    takeProfit = closePrice + atr * this.profitTargetMultiplier;
                } else {
                    stopLoss = closePrice + atr * this.trailingStopMultiplier;
                    takeProfit = closePrice - atr * this.profitTargetMultiplier;
                }
                new_df.at(i, "signal", signal);
                new_df.at(i, "confidence", confidence);
                new_df.at(i, "position_size", position_size);
                new_df.at(i, "leverage", Math.min(leverage, this.maxLeverage));
                new_df.at(i, "stop_loss", stopLoss);
                new_df.at(i, "take_profit", takeProfit);
            }
        }
        return new_df;
    }
}

// src/mastra-agent.ts
import { StrikeFinanceAPI } from "./strike-finance-api";
import { TradingStrategy, TradingDecision } from "./trading-strategies";
import { OpenPositionRequest } from "./interfaces";
import { CardanoWallet } from "./cardano-wallet";
import { PriceService } from "./price-service";
import * as pd from "danfojs-node";

export class MastraAgent {
  private readonly strikeFinanceAPI: StrikeFinanceAPI;
  private readonly tradingStrategy: TradingStrategy;
  private readonly wallet: CardanoWallet;
  private readonly priceService: PriceService;
  private priceData: pd.DataFrame;


  constructor(tradingStrategy: TradingStrategy, wallet: CardanoWallet) {
    this.strikeFinanceAPI = new StrikeFinanceAPI();
    this.tradingStrategy = tradingStrategy;
    this.wallet = wallet;
    this.priceService = new PriceService();
    this.priceData = new pd.DataFrame([], { columns: ["time", "open", "high", "low", "close", "volume"] });
  }

  /**
   * Runs a single iteration of the trading bot's logic.
   */
  async run() {
    console.log("Mastra Agent is running...");

    // 1. Get latest price data
    const newPrice = await this.priceService.getAdaPrice();
    const newRow = {
        time: new Date().getTime(),
        open: this.priceData.shape[0] > 0 ? this.priceData.iloc(this.priceData.shape[0] - 1)["close"] : newPrice,
        high: newPrice,
        low: newPrice,
        close: newPrice,
        volume: 0,
    };

    const new_df = new pd.DataFrame([newRow]);
    this.priceData.append(new_df, {inplace: true});


    // 2. Get market info
    const marketInfo = (await this.strikeFinanceAPI.getOverallInfo()).data;

    // 3. Get existing positions
    const existingPositions = await this.strikeFinanceAPI.getPositions(this.wallet.address);

    // 4. Evaluate trading strategy
    const decision = this.tradingStrategy.evaluate(marketInfo, existingPositions, this.priceData);

    // 5. Execute trading decision
    await this.executeDecision(decision, newPrice);
  }

  private async executeDecision(decision: TradingDecision, currentPrice: number) {
    switch (decision.action) {
      case "Open":
        console.log("Executing Open action...");
        const openPositionRequest: OpenPositionRequest = {
            request: {
                bech32Address: this.wallet.address,
                leverage: decision.params.leverage,
                position: decision.params.position,
                asset: {
                    policyId: "", // ADA policyId
                    assetName: "" // ADA assetName in hex
                },
                collateralAmount: decision.params.collateralAmount,
                positionSize: decision.params.positionSize,
                enteredPrice: currentPrice,
                positionType: decision.params.position,
            }
        };
        try {
            const result = await this.strikeFinanceAPI.openPosition(openPositionRequest);
            await this.wallet.signAndSubmitTx(result.cbor);
        } catch (error) {
            console.error("Error opening position:", error);
        }
        break;
      case "Close":
        console.log("Executing Close action...");
        // Implement close logic
        break;
      case "Update":
        console.log("Executing Update action...");
        // Implement update logic
        break;
      case "Hold":
        console.log("Executing Hold action.");
        break;
    }
  }
}

// src/main.ts
import { MastraAgent } from "./mastra-agent";
import { TITAN2KTrendTuned } from "./strategies/titan2k-trend-tuned";
import { CardanoWallet } from "./cardano-wallet";


async function main() {
    // IMPORTANT: Replace with your actual private key
    const privateKeyBech32 = "xprv1...";
    if (privateKeyBech32 === "xprv1...") {
        console.error("Please replace the placeholder private key in src/main.ts");
        return;
    }


    const wallet = new CardanoWallet(privateKeyBech32);
    const strategy = new TITAN2KTrendTuned();
    const agent = new MastraAgent(strategy, wallet);

    // Run the agent every 30 seconds
    setInterval(() => {
        agent.run();
    }, 30000);
}

main().catch(error => {
    console.error("An unexpected error occurred:", error);
});


// src/trading-strategies.ts
import { MarketInfo, PerpetualInfo } from "./interfaces";
import * as pd from "danfojs-node";

export abstract class TradingStrategy {
    /**
     * Evaluates the market conditions and decides on a trading action.
     * @param marketInfo - The current market information.
     * @param existingPositions - The existing positions for the agent.
     * @param priceData - The historical price data.
     * @returns A trading decision.
     */
    abstract evaluate(marketInfo: MarketInfo, existingPositions: PerpetualInfo[], priceData: pd.DataFrame): TradingDecision;
}

export type TradingAction = "Open" | "Close" | "Update" | "Hold";
export interface TradingDecision {
    action: TradingAction;
    params?: any;
}
